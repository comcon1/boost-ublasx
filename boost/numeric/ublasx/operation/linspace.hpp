/**
 * \file boost/numeric/ublasx/operation/linspace.hpp
 *
 * \brief Linearly spaced vector
 *
 * Inspired by MATLAB's linspace function.
 *
 * <hr/>
 *
 * Copyright (c) 2013, Marco Guazzone
 * 
 * Distributed under the Boost Software License, Version 1.0. (See
 * accompanying file LICENSE_1_0.txt or copy at
 * http://www.boost.org/LICENSE_1_0.txt)
 *
 * \author Marco Guazzone (marco.guazzone@gmail.com)
 */

#ifndef BOOST_NUMERIC_UBLASX_OPERATION_LINSPACE_HPP
#define BOOST_NUMERIC_UBLASX_OPERATION_LINSPACE_HPP


#include <boost/numeric/ublas/exception.hpp>
#include <boost/numeric/ublas/vector.hpp>
#include <cstddef>


namespace boost { namespace numeric { namespace ublasx {

using namespace ::boost::numeric::ublas;

/**
 * Generates a linearly spaced vector.
 *
 * Generates \a n values linearly spaced between \a a and \a b.
 * Note, in case \f$a<b\f$, generates a decreasing sequence.
 *
 * Inspired by MATLAB's linspace function.
 *
 * \param a The starting value of the linearly spaced sequence.
 * \param b The final value of the linearly spaced sequence.
 * \return A vector of linearly spaced values in \f$[a,b]\f$; if
 *  <code>n=1</code>, returns \a b.
 *
 * \author Marco Guazzone (marco.guazzone@gmail.com)
 */
template <typename ValueT>
BOOST_UBLAS_INLINE
vector<ValueT> linspace(ValueT a, ValueT b, ::std::size_t n = 100)
{
	// pre: n > 0
	BOOST_UBLAS_CHECK( n > 0,
					   bad_argument() );

	if (n < 2)
	{
		return scalar_vector<ValueT>(1, b);
	}

	vector<ValueT> x(n);

	--n;

	// Check for possible overflows generated by opposite signs
	ValueT c((b-a)*(n-1));
	if (::std::isinf(c))
	{
		// Overflows is happened => split computations
		for (::std::size_t i = 0; i <= n; ++i)
		{
			x[i] = a + (b/n)*i - (a/n)*i;
		}
	}
	else
	{
		// No overflow
		for (::std::size_t i = 0; i <= n; ++i)
		{
			x[i] = a + ((b-a)/n)*i;
		}
	}

	// just make sure that endpoints are honored
	x[0] = a;
	x[n] = b;

	return x;
}

}}} // Namespace boost::numeric::ublasx


#endif // BOOST_NUMERIC_UBLASX_OPERATION_LINSPACE_HPP
